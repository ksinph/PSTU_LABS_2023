# Вариант задания
Лабораторная работа по классам №7, вариант 11. 
Класс- контейнер СПИСОК с ключевыми значениями типа int.

Реализовать операции:

[]- доступа по индексу;

int() - определение размера списка;

+ вектор сложение элементов списков а[i]+b[i];

Пользовательский класс Money для работы с денежными суммами. Число должно быть представлено двумя полями: типа long для рублей и типа int для копеек. Дробная часть числа при выводе на экран должна быть отделена от целой части запятой.
# Код программы
```cpp
#include <iostream>
#include "plurality.h"
#include "money.h"

using namespace std;

class Money
{
public:
	Money(void);
	Money(long, int);
	Money(const Money&);
	Money& operator=(const Money&);

	friend ostream& operator<<(ostream& out, const Money&);
	friend istream& operator>>(istream& in, Money&);
	virtual ~Money(void) { rubles = 0; kop = 0; };

	void operator!=(const Money& t);
private:
	long rubles;
	int kop;
};

Money::Money(void)
{
	rubles = 0;
	kop = 0;
}

Money::Money(long r, int k)
{
	rubles = r;
	kop = k;
}

Money::Money(const Money& t)
{
	rubles = t.rubles;
	kop = t.kop;
}

Money& Money::operator=(const Money& t)
{
	rubles = t.rubles;
	kop = t.kop;
	return *this;
}

ostream& operator<<(ostream& out, const Money& t)
{
	out << t.rubles << " , " << t.kop;
	return out;
}

istream& operator>>(istream& in, Money& t)
{
	cout << "Введите рубли: "; in >> t.rubles;
	cout << "Введите копейки: "; in >> t.kop;
	return in;
}

void Money::operator!=(const Money& t)
{
	if (rubles == t.rubles && kop == t.kop) cout << "Равны" << endl;
	else cout << "Не равны" << endl;
}

template <class T>
class Plurality {
private:
	T size;
	T* array;
public:
	Plurality(T size);
	virtual void show();
	~Plurality();
	int& operator ()();
	Plurality operator +(const Plurality& other);
	T& operator [](int index);
};

template<class T>
Plurality<T>::Plurality(T size) {
	this->size = size;
	array = new T[size];
	for (int i = 0; i < size; i++) {
		array[i] = rand() % 100 + 1;
	}
}
template<class T>
void Plurality<T>::show() {
	for (int i = 0; i < size; i++) {
		cout << array[i] << " ";
	}
	cout << endl;
}

template<class T>
Plurality<T>::~Plurality() {}

template<class T>
int& Plurality<T>::operator()() {
	return size;
}

template<class T>
Plurality<T> Plurality<T>::operator+(const Plurality& other) {
	Plurality<T> tmp(size);
	for (int i = 0; i < size; i++) {
		tmp[i] = array[i] + other.array[i];
	}
	delete[]array;
	return tmp;
}

template<class T>
T& Plurality<T>::operator [](int index) {
	if (index >= 0 && index < size) {
		return array[index];
	}
	else {
		cout << "Ошибка" << endl;
	}
}

int main() {
	system("chcp 1251");
	int size;
	cout << "Введите размер списка: " << endl;
	cin >> size;
	Plurality<int> A(size);
	cout << "Список A: "; A.show();
	int k;
	cout << "Введите индекс: " << endl;
	cin >> k;
	cout << "A[k] элемент: " << A[k] << endl;
	cout << "Размер списка A: " << A() << endl;
	cout << endl;
	cout << "Введите размер списка: " << endl;
	cin >> size;
	Plurality<int> B(size);
	cout << "Список B: "; B.show();
	cout << "Размер списка B: " << B() << endl;
	cout << endl;

	Plurality<int> C(size);
	C = A + B;
	cout << "Список C = A + B: "; C.show();
	cout << "Размер списка C: " << C() << endl;
	cout << endl;

	cout << "Тестирование класса Money:" << endl;

	Money t1;
	cin >> t1;
	cout << "Первый экземпляр класса Money:" << endl;
	cout << t1; cout << endl;

	Money t2;
	cin >> t2;
	cout << "Второй экзепляр класса Money: " << endl;
	cout << t2; cout << endl;

	cout << "Проверка их на неравенство: " << endl;
	t1 != t2;

	return 0;
}
```
# Блок-схема программы
<image src="class7.png">
	
# Тесты
### Пример 1
Входные данные:
```
Введите размер списка:
0
Введите индекс:
1
```
Выходные данные:
```
Ошибка
```
### Пример 2
Входные данные:
```
Введите размер списка:
4
Введите индекс:
1
Введите рубли: 32
Введите копейки: 56
Введите рубли: 12
Введите копейки: 34
```
Выходные данные:
```
Список A: 42 68 35 1
A[k] элемент: 68
Размер списка A: 4

Введите размер списка:
4
Список B: 70 25 79 59
Размер списка B: 4

Список C = A + B: 112 93 114 60
Размер списка C: 4

Тестирование класса Money:

Первый экземпляр класса Money:
32 , 56

Второй экзепляр класса Money:
12 , 34
Проверка их на неравенство:
Не равны
```
### Пример 3
Входные данные:
```
Введите размер списка:
3
Введите индекс:
2
Введите рубли: 23
Введите копейки: 34
Введите рубли: 23
Введите копейки: 34
```
Выходные данные:
```
Список A: 42 68 35
A[k] элемент: 35
Размер списка A: 3
Список B: 1 70 25
Размер списка B: 3
Проверка их на неравенство:
Равны
```
# Контрольные вопросы
1. В чем смысл использования шаблонов?
С помощью шаблона функций можно отделить алгоритм от конкретных типов данных, передавая тип в качестве параметра. Шаблоны классов предоставляют аналогичную возможность, позволяя создавать параметризированные классы. Параметризированный класс создает семейство родственных классов, которые можно применять к любому типу данных, передаваемому в качестве параметра. Если использовать в качестве параметризированного класса контейнер, то такой контейнер можно будет применять к любым типам данных, не переписывая код.
Шаблон служит для автоматического формирования конкретных описаний
функций по тем вызовам, которые компилятор обнаруживает в программе. 

2. Каковы синтаксис/семантика шаблонов функций?
template <параметры_шаблона> 
заголовок_функции (параметры_функции)
{тело функции}
Пример
template <typename T>
T abs(T x) {
	if (x>0) return x;
	else return -x;
}

3. Каковы синтаксис/семантика шаблонов классов?
template <параметры шаблона>
class имя_класса
{…};
Пример
template <class T>
class Point {
T x,y;//координаты точки
public:
Point(T X=0,T Y=0):x(X),y(Y){}
void Show ();
};
template<class T>
void Point::Show() { cout<<”(“<<x<<” , ”<<y<<”)”;}
Экземпляр создается либо объявлением объекта, либо объявлением указателя на инстанцированный шаблонный тип с присваиванием ему адреса с помощью операции new.
Point <int> a(13,15);
Point <float>*pa=new Point<float>(10.1,0.55);

4. Что такое параметры шаблона функции?
Можно считать, что параметры шаблона являются его формальными параметрами, а типы тех параметров, которые используются в конкретных обращениях к функции, служат фактическими параметрами шаблона. Именно по ним выполняется параметрическая настройка и с учетом этих типов генерируется конкретный текст определения функции.
template <typename T>
T abs(T x) {
	if (x>0) return x;
	else return -x;
}
Если в программе вызов функции осуществляется как abs(-1.5), то компилятор формирует определение функции double abs(double x)

5. Перечислите основные свойства параметров шаблона функции.
-	Имена параметров шаблона должны быть уникальными во всем определении шаблона.
-	Список параметров шаблона не может быть пустым, для того, чтобы компилятор мог инстанцировать шаблон.
-	В списке параметров шаблона может быть несколько параметров, и каждому из них должно предшествовать ключевое слово class.
template<class type1, class type2>
Соответственно, неверен заголовок:
template<class type1, type2, type3>
-	Недопустимо использовать в заголовке шаблона параметры с одинаковыми именами, то есть ошибочен такой заголовок:
template<class t, class t, class t>
-	Имя параметра шаблона имеет все права имени типа в определенной шаблоном функции.
-	Все параметры шаблона функций должны быть обязательно использованы в спецификациях параметров определения функции. Таким образом, будет ошибочным такой шаблон:
template<class A, class B, class C>
B func(A n, C m) { B value; };
-	Определенная с помощью шаблона функция может иметь любое количество непараметризованных формальных параметров. Может быть непараметризованно и возвращаемое функцией значение. Например, в следующей программе шаблон определяет семейство функций, каждая из которых подсчитывает количество нулевых элементов одномерного массива параметризованного типа:
template<class D> long count0(int, D *); //Прототип шаблона
int main(void) {
  	int A[] = { 1, 0, 6, 0, 4, 10 };
  	int n = sizeof(A) / sizeof A[0];
  	cout << "\ncount0(n,A) = " << count0(n, A);
  	float X[] = { 10.0, 0.0, 3.3, 0.0, 2.1 };
 	n = sizeof(X) / sizeof X[];
 	cout << "\ncount0(n,X) = " << count0(n, X);
	return 0; }
-	В списке параметров прототипа шаблона имена параметров не обязаны совпадать с именами тех же параметров в определении шаблона.
-	При конкретизации шаблонного определения функции необходимо, чтобы при вызове функции типы фактических параметров, соответствующие одинаково параметризованным формальным параметрам, были одинаковыми. Для определенного ниже шаблона функций с данным прототипом недопустимо использовать такое обращение к функции:
template<class E> void swap(E, E);
int n = 4; 
double d = 4.3; 
swap(n, d); // Ошибка в типах параметров
swap(double(n), d); // Правильные типы параметров
Для правильного обращения к такой функции требуется явное приведение типа одного из параметров.
-	При использовании шаблонов функций возможна перегрузка как шаблонов, так и функций. Могут быть шаблоны с одинаковыми именами, но разными параметрами. Или с помощью шаблона может создаваться функция с таким же именем, что и явно определенная функция. В обоих случаях "распознавание" конкретного вызова выполняется по сигнатуре, т.е. по типам, порядку и количеству фактических параметров.
6. Как записывать параметр шаблона?
-	Каждому из разных типов параметров должно предшествовать ключевое слово class. Пример: template<class type1, class type2>
-	Все параметры шаблона функций должны быть обязательно использованы в спецификациях параметров определения функции.
-	Недопустимо использовать в заголовке шаблона параметры с одинаковыми именами, то есть ошибочен такой заголовок:
template<class t, class t, class t>
7. Можно ли перегружать параметризованные функции?
Да. Шаблон функции может перегружать функции, отличные от шаблона, с тем же именем. В этом сценарии компилятор сначала пытается разрешить вызов функции с помощью вычета аргументов шаблона для создания экземпляра шаблона функции с уникальной специализацией.
Пример
template <typename T>
void print(T value) {cout << “Шаблон” << value;}
template <>
void print(int value) {cout << “Специализация для int” << value;}
void print(int value) {cout << “Перегрузка для int” << value;}
8. Перечислите основные свойства параметризованных классов.
-	В определении класса, входящего шаблон, имя класса является не именем отдельного класса, а параметризованным именем семейства классов. 
-	Компонентные функции параметризованного класса автоматически являются параметризованными. Их не обязательно объявлять как параметризованные с помощью template.
-	Дружественные функции, которые описываются в параметризованном классе, не являются автоматически параметризованными функциями, т.е. по умолчанию такие функции являются дружественными для всех классов, которые организуются по данному шаблону.
-	Если friend-функция содержит в своем описании параметр типа параметризованного класса, то для каждого созданного по данному шаблону класса имеется собственная friend-функция.
-	С одной стороны, шаблоны могут быть производными (наследоваться) как от шаблонов, так и от обычных классов, с другой стороны, они могут использоваться в качестве базовых для других шаблонов или классов.
-	Локальные классы не могут содержать шаблоны в качестве своих элементов.
9. Все ли компонентные функции параметризованного класса являются
параметризованными?
-	Компонентные функции параметризованного класса автоматически являются параметризованными. Их не обязательно объявлять как параметризованные с помощью template.
10. Являются ли дружественные функции, описанные в параметризованном классе, параметризованными?
В рамках параметризованного класса нельзя определить friend-шаблоны (дружественные параметризованные классы).

11. Могут ли шаблоны классов содержать виртуальные компонентные функции?
Шаблоны функций, которые являются членами классов, нельзя описывать как virtual.

12. Как определяются компонентные функции параметризованных классов вне определения шаблона класса?
Реализация компонентной функции шаблона класса, которая находится вне определения шаблона класса, должна включать дополнительно следующие два элемента:
-	Определение должно начинаться с ключевого слова template, за которым следует такой же список_параметров_типов в угловых скобках, какой указан в определении шаблона класса.
-	За именем_класса, предшествующим операции области видимости (::), должен следовать список_имен_параметров шаблона.
template<список_типов>тип_возвр_значения имя_класса<список_имен_ параметров> : : имя_функции(список_параметров){ . . . }
13. Что такое инстанцирование шаблона?
Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
Неявное инстанцирование:
template <typename T>
T sqrt(T x) {return x*x;}
Если в программе вызов функции осуществляется как sqrt(-1), то компилятор формирует определение функции int sqrt(int x)
Явное инстанцирование:
template <typename T>
T sqrt(T x) {return x*x;}
template double sqrt(double); 
template int sqrt(int); 
Через явное инстанцирование будут доступны только те типы, которые были явно инстанцированы ключевым словом template.

14. На каком этапе происходит генерирование определения класса по шаблону?
Компилятор производит генерацию кода по шаблону, когда происходит явное или неявное инстанцирование. Это может существенно увеличить время компиляции и компоновки, особенно в тех случаях, когда шаблон инстанцируется с одинаковыми параметрами во многих модулях. С помощью extern теперь можно указать компилятору не инстанцировать шаблон в данной единице трансляции (файле)
extern template vector<int>; 
Естественно, в одном из модулей должно быть сделано явное или неявное инстанцирование, чтобы при компоновке программы все ссылки были разрешены.
template vector<int>;
